C $Header: /home/jahn/src/cvs2git/MITgcm/20170915-2/gcmpack-all-patch/MITgcm/eesupp/src/Attic/exch_z_rx_cube.template,v 1.1.2.3 2001/04/09 18:50:07 adcroft Exp $
C $Name:  $

#include "CPP_EEOPTIONS.h"

      SUBROUTINE EXCH_Z_RX_CUBE( 
     U            array,
     I            myOLw, myOLe, myOLn, myOLs, myNz,
     I            exchWidthX, exchWidthY,
     I            simulationMode, cornerMode, myThid )
C     /==========================================================\
C     | SUBROUTINE EXCH_Z_RX_CUBE                                |
C     | o Control edge exchanges for RX array.                   |
C     |==========================================================|
C     |                                                          |
C     | Controlling routine for exchange of XY edges of an array |
C     | distributed in X and Y. The routine interfaces to        |
C     | communication routines that can use messages passing     |
C     | exchanges, put type exchanges or get type exchanges.     |
C     |  This allows anything from MPI to raw memory channel to  |
C     | memmap segments to be used as a inter-process and/or     |
C     | inter-thread communiation and synchronisation            |
C     | mechanism.                                               |
C     | Notes --                                                 |
C     | 1. Some low-level mechanisms such as raw memory-channel  |
C     | or SGI/CRAY shmem put do not have direct Fortran bindings|
C     | and are invoked through C stub routines.                 |
C     | 2. Although this routine is fairly general but it does   |
C     | require nSx and nSy are the same for all innvocations.   |
C     | There are many common data structures ( myByLo,          |
C     | westCommunicationMode, mpiIdW etc... ) tied in with      |
C     | (nSx,nSy). To support arbitray nSx and nSy would require |
C     | general forms of these.                                  |
C     |                                                          |
C     \==========================================================/
      IMPLICIT NONE

C     == Global data ==
#include "SIZE.h"
#include "EEPARAMS.h"
#include "EESUPPORT.h"
#include "EXCH.h"

C     == Routine arguments ==
C     array - Array with edges to exchange.
C     myOLw - West, East, North and South overlap region sizes.
C     myOLe
C     myOLn
C     myOLs
C     exchWidthX - Width of data region exchanged in X.
C     exchWidthY - Width of data region exchanged in Y.
C                  Note -- 
C                  1. In theory one could have a send width and
C                  a receive width for each face of each tile. The only
C                  restriction woul be that the send width of one
C                  face should equal the receive width of the sent to
C                  tile face. Dont know if this would be useful. I 
C                  have left it out for now as it requires additional 
C                  bookeeping.
C     simulationMode - Forward or reverse mode exchange ( provides 
C                      support for adjoint integration of code. )
C     cornerMode     - Flag indicating whether corner updates are 
C                      needed.
C     myThid         - Thread number of this instance of S/R EXCH...
      INTEGER myOLw
      INTEGER myOLe
      INTEGER myOLs
      INTEGER myOLn
      INTEGER myNz
      INTEGER exchWidthX
      INTEGER exchWidthY
      INTEGER simulationMode
      INTEGER cornerMode
      INTEGER myThid
      _RX array(1-myOLw:sNx+myOLe,
     &          1-myOLs:sNy+myOLn, 
     &          myNZ, nSx, nSy)

C     == Local variables ==
C     theSimulationMode - Holds working copy of simulation mode
C     theCornerMode     - Holds working copy of corner mode
      INTEGER theSimulationMode
      INTEGER theCornerMode
      INTEGER I,J,K,repeat
      INTEGER bl,bt,bn,bs,be,bw

C     == Statement function ==
      INTEGER tilemod
      tilemod(I)=1+mod(I-1+6,6)

      theSimulationMode = simulationMode
      theCornerMode     = cornerMode

      DO repeat=1,2

      DO bl = 1, 5, 2

       bt = bl
       bn=tilemod(bt+2)
       bs=tilemod(bt-1)
       be=tilemod(bt+1)
       bw=tilemod(bt-2)

       DO K = 1, myNz
        DO J = 1, sNy+1
         DO I = 0, exchWidthX-1

C Tile Odd:Odd+2 [get] [North<-West]
          array(J,sNy+I+1,K,bt,1) = array(I+1,sNy+2-J,K,bn,1)
C Tile Odd:Odd+1 [get] [East<-West]
          array(sNx+I+1,J,K,bt,1) = array(I+1,J,K,be,1)

cs- these above loop should really have the same range the lower one
         ENDDO
         DO I = 1, exchWidthX-0
cs- but this replaces the missing I/O routines for now

C Tile Odd:Odd-1 [get] [South<-North]
          array(J,1-I,K,bt,1) = array(J,sNy+1-I,K,bs,1)
C Tile Odd:Odd-2 [get] [West<-North]
          array(1-I,J,K,bt,1) = array(sNx+2-J,sNy+1-I,K,bw,1)

         ENDDO
        ENDDO
       ENDDO

       bt = bl+1
       bn=tilemod(bt+1)
       bs=tilemod(bt-2)
       be=tilemod(bt+2)
       bw=tilemod(bt-1)

       DO K = 1, myNz
        DO J = 1, sNy+1
         DO I = 0, exchWidthX-1

C Tile Even:Even+1 [get] [North<-South]
          array(J,sNy+I+1,K,bt,1) = array(J,I+1,K,bn,1)
C Tile Even:Even+2 [get] [East<-South]
          array(sNx+I+1,J,K,bt,1) = array(sNx+2-J,I+1,K,be,1)

cs- these above loop should really have the same range the lower one
         ENDDO
         DO I = 1, exchWidthX-0
cs- but this replaces the missing I/O routines for now

C Tile Even:Even-2 [get] [South<-East]
          array(J,1-I,K,bt,1) = array(sNx+1-I,sNy+2-J,K,bs,1)
C Tile Even:Even-1 [get] [West<-East]
          array(1-I,J,K,bt,1) = array(sNx+1-I,J,K,bw,1)

         ENDDO
        ENDDO
       ENDDO

      ENDDO

      ENDDO

      RETURN
      END
