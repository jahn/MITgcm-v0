#! /usr/bin/env bash
#
#  $Header: /home/jahn/src/cvs2git/MITgcm/20170915-2/gcmpack-all-patch/MITgcm/verification/testreport,v 1.24 2003/11/30 01:28:51 edhill Exp $
#  $Name:  $
#

usage()
{
    echo
    echo "Usage:  $0 [OPTIONS]"
    echo
    echo "where possible OPTIONS are:"
    echo "  (-help|-h)               print usage"
    echo "  (-mpi)                   use MPI input files"
    echo "  (-ieee|-noieee)          if possible, use IEEE compiler flags"
    echo "                             (DEF=\"noieee\")"
    echo "  (-optfile=|-of=)STRING   list of optfiles to use"
    echo "  (-a|-addr) STRING        list of email recipients"
    echo "                             (DEF=\"edhill@mitgcm.org\")"
    echo "  (-t|-tdir) STRING        list of test dirs to use"
    echo "                             (DEF=\"\" which builds all)"
    echo "  (-b|-bash) STRING        preferred location of a \"bash\" or"
    echo "                             Bourne-compatible \"sh\" shell"
    echo "                             (DEF=\"\" for \"bash\")"
    echo "  (-adm|-ad)               perform an adjoint run"
    echo "  (-command) STRING        command to run"
    echo "                             (DEF=\"make output.txt\")"
    echo "  (-m|-make) STRING        command to use for \"make\""
    echo "                             (DEF=\"make\")"
    echo "  (-clean)                 *ONLY* run \"make CLEAN\""
    echo "  (-quick|-q)              same as \"-nogenmake -noclean -nodepend\""
    echo "  (-nogenmake|-ng)         skip the genmake stage"
    echo "  (-noclean|-nc)           skip the \"make clean\" stage"
    echo "  (-nodepend|-nd)          skip the \"make depend\" stage"
    echo
    echo "and where STRING follows a whitespace-delimited format"
    echo "such as:"
    echo "  -t 'exp0 exp2 exp3' "
    echo "  -addr='abc@123.com testing@home.org'"
    echo
    exit 1
}

#  build the mpack utility
build_mpack()
{
    echo -n "building the mpack utility...  "
    if test ! -x "$MPACKDIR/mpack" ; then
	if test ! -d $MPACKDIR ; then
	    echo
	    echo "Error: can't find \"$MPACKDIR\""
	    echo "  are you sure this program is being run in the correct "
	    echo "  (that is, \"MITGCM_ROOT\verification\") directory?"
	    echo
	    HAVE_MPACK=f
	fi
	echo -n "building mpack...  "
	( cd $MPACKDIR && ./configure && $MAKE ) > build_mpack.out 2>&1
	RETVAL=$?
	if test "x$RETVAL" != x0 ; then
	    echo
	    echo "Error building the mpack tools at: $MPACK_DIR"
	    echo
	    HAVE_MPACK=f
	else
	    HAVE_MPACK=t
	fi
    else
	HAVE_MPACK=t
    fi
    echo "OK"
}

testoutput_for_prop()
{
    # testoutput_for_prop dir s1 label subdir
    #
    #  compares files in $dir/$subdir/output.txt and $dir/results/output.txt
    #  using search strings s1 and text label 

    if [ $debug -gt 0 ]; then
	echo testoutput_for_prop: grep "$2" $1/$4/output.txt 1>&2
    fi
    if [ -r $1/$4/output.txt ]; then
	grep "$2" $1/$4/output.txt | sed 's/.*=//' | cat -n > tmp1.txt
	lncnt=`wc -l tmp1.txt | awk '{print $1}' `
	if [ $lncnt -lt 3 ]; then
	    if [ $verbose -gt 0 ]; then
		echo Not enough lines of output when searching for "$2" 1>&2
	    fi
	    return 99
	fi
    else
	echo testoutput_for_prop: output.txt from model run was not readable 1>&2
	return 99
    fi
    if [ $debug -gt 0 ]; then
	echo testoutput_for_prop: grep "$2" $1/results/output.txt 1>&2
    fi
    grep "$2" $1/results/output.txt | sed 's/.*=//' | cat -n > tmp2.txt
    lncnt=`wc -l tmp2.txt | awk '{print $1}' `
    if [ $lncnt -lt 3 ]; then
	if [ $verbose -gt 0 ]; then
	    echo Not enough lines of output when searching for "$2" 1>&2
	fi
	return 99
    fi
    if [ $debug -gt 0 ]; then
	echo testoutput_for_prop: join tmp1.txt tmp2.txt 1>&2
    fi
    join tmp1.txt tmp2.txt | awk '{print $1 " " $2 " " $3}' > tmp3.txt
    if [ $debug -gt 0 ]; then
	echo testoutput_for_prop: compare_lines 1>&2
    fi
    if [ $verbose -gt 1 ]; then
	cat tmp3.txt 1>&2
    fi
    echo "-1" >> tmp3.txt
    # On the SGI O3K (*not* the O2K), "cat -n" inserts a ":" after the line number
    cat tmp3.txt | sed -e 's|:||g' > tmp4.txt
    digits_of_similarity=`./tmp_cmpnum < tmp4.txt`
    if [ $digits_of_similarity -eq 99 ]; then
	if [ $verbose -gt 0 ]; then
	    echo testoutput_for_prop: No comparison was available for \"$2\" 1>&2
	fi
	digits_of_similarity=99
    else
	if [ $verbose -gt 0 ]; then
	    echo There were $digits_of_similarity decimal places of similarity for \"$2\" 1>&2
	fi
    fi
    rm -f tmp1.txt tmp2.txt tmp3.txt tmp4.txt
    
    return $digits_of_similarity
}

dashnum()
{
    # dashnum n1 n2 n3 ...
    #
    #  print numbers using %3i format or "--" if number = 99

    for num in $@ ; do
	if [ $num = 99 ]; then
	    printf ' --'
	else
	    printf '%3i' $num
	fi
    done
}

testoutput_ad()
{
    grep $3 $1/results_ad/output.txt_adm | awk '{print NR " " $5}' > t05.txt
    grep $3 $1/$2/output.txt_adm | awk '{print NR " " $5}' > t15.txt
    grep $3 $1/results_ad/output.txt_adm | awk '{print NR " " $6}' > t06.txt
    grep $3 $1/$2/output.txt_adm | awk '{print NR " " $6}' > t16.txt
    join t05.txt t15.txt > t5.txt
    join t06.txt t16.txt > t6.txt
    echo "-1" >> t5.txt
    echo "-1" >> t6.txt
    digits_5=`./tmp_cmpnum < t5.txt`
    digits_6=`./tmp_cmpnum < t6.txt`
    dashnum $digits_5 $digits_6
    rm -f t[01][56].txt t[56].txt
}

testoutput()
{
    # testoutput directory subdir
    #
    #  test output in "directory"
    if test "x$ADM" = x ; then
	if [ $debug -gt 0 ]; then
	    echo testoutput: testoutput_for_prop $1 cg2d_init_res 1>&2
	fi
	testoutput_for_prop $1 "cg2d_init_res" "cg2d init. residual" $2; cg2dres=$?
	if [ $debug -gt 0 ]; then
	    echo testoutput: cg2dres=$cg2dres 1>&2
	fi
	testoutput_for_prop $1 "dynstat_theta_min" "theta minimum" $2; tmin=$?
	testoutput_for_prop $1 "dynstat_theta_max" "theta maximum" $2; tmax=$?
	testoutput_for_prop $1 "dynstat_theta_mean" "theta mean" $2; tmean=$?
	testoutput_for_prop $1 "dynstat_theta_sd" "theta s.d." $2; tsd=$?
	testoutput_for_prop $1 "dynstat_salt_min" "salt minimum" $2; smin=$?
	testoutput_for_prop $1 "dynstat_salt_max" "salt maximum" $2; smax=$?
	testoutput_for_prop $1 "dynstat_salt_mean" "salt mean" $2; smean=$?
	testoutput_for_prop $1 "dynstat_salt_sd" "salt s.d." $2; ssd=$?
	testoutput_for_prop $1 "dynstat_uvel_min" "U minimum" $2; umin=$?
	testoutput_for_prop $1 "dynstat_uvel_max" "U maximum" $2; umax=$?
	testoutput_for_prop $1 "dynstat_uvel_mean" "U mean" $2; umean=$?
	testoutput_for_prop $1 "dynstat_uvel_sd" "U s.d." $2; usd=$?
	testoutput_for_prop $1 "dynstat_vvel_min" "V minimum" $2; vmin=$?
	testoutput_for_prop $1 "dynstat_vvel_max" "V maximum" $2; vmax=$?
	testoutput_for_prop $1 "dynstat_vvel_mean" "V mean" $2; vmean=$?
	testoutput_for_prop $1 "dynstat_vvel_sd" "V s.d." $2; vsd=$?
	dashnum $cg2dres $tmin $tmax $tmean $tsd $smin $smax $smean $ssd \
	    $umin $umax $umean $usd $vmin $vmax $vmean $vsd
    else
	testoutput_ad $1 $2 "precision_grdchk_result"
    fi
}

genmakemodel()
{
    # genmakemodel directory
    if test "x$NOGENMAKE" = xt ; then
	echo "genmake skipped!"
    else
	GENMAKE2="$BASH ../../../tools/genmake2"
	(
	    cd $1;
	    command="$GENMAKE2  -ds -m $MAKE"
	    if test "x$ADM" = x ; then
		command="$command --mods=../code"
	    else
		command="$command --mods=../code_ad"
		command="$command -adof=../../../tools/adjoint_options/adjoint_staf"
	    fi
	    if test "x$OPTFILE" != xNONE ; then
		command="$command --optfile=$OPTFILE"
	    fi
	    if test "x$IEEE" != x ; then
		command="$command -ieee"
	    fi
	    printf 'genmake ... ' 1>&2
	    $command > make.log 2>&1
	    RETVAL=$?
	    cp Makefile $CDIR
	    if test "x$RETVAL" != x0 ; then
		tail make.log
		echo "genmakemodel: genmake failed" 1>&2
		cp genmake_* make.log $CDIR
		return 1
	    else
		echo "successful" 1>&2
	    fi
	)
    fi
}

makeclean()
{
    # makeclean directory
    if test "x$NOCLEAN" = xt ; then
	echo "make CLEAN skipped!"
    else
	(
	    cd $1;
	    if test -e output.txt ; then
		rm -f output.txt
	    fi
	    printf 'make CLEAN ... ' 2>&1
	    if test -r Makefile ; then
		$MAKE CLEAN >> make.log 2>&1
		RETVAL=$?
		if test "x$RETVAL" != x0 ; then
		    tail make.log
		    echo "makeclean: \"make CLEAN\" failed" 1>&2
		    cp make.log $CDIR"/make.log"
		    return 1
		fi
	    fi
	    echo successful 1>&2
	    exit 0
	)
    fi
}

makedependmodel()
{
    # makedependmodel directory
    if test "x$NODEPEND" = xt ; then
	echo "make depend skipped!"
    else
	(
	    cd $1;
	    printf 'make depend ... ' 1>&2
	    $MAKE depend >> make.log 2>&1
	    RETVAL=$?
	    if test "x$RETVAL" != x0 ; then
		tail make.log
		echo "makedependmodel: make depend failed" 1>&2
		cp make.log $CDIR"/make.log"
		return 1
	    else
		echo successful 1>&2
	    fi
	)
    fi
}

makemodel()
{
    # makemodel directory
    (
	cd $1;
	if test -r Makefile ; then
	    printf 'make ... ' 1>&2
	    if test "x$ADM" = x ; then
		$MAKE >> make.log 2>&1
	    else
		$MAKE adall >> make.log 2>&1
	    fi
	    RETVAL=$?
	    if test "x$RETVAL" != x0 ; then
		tail make.log
		echo failed 1>&2
		cp make.log $CDIR"/make.log"
		return 1
	    else
		echo successful 1>&2
	    fi
	fi
    )
}

linkdata()
{
    # linkdata flag
    #
    # symbolically link data files to run directory
    if test "x$1" = x1 ; then
	(
	    cd $2
	    if test "x$ADM" = x ; then
		files=`( cd ../input ; ls -1 | grep -v CVS )`
		for i in $files ; do
		    if test ! -d "../input/"$i ; then
			ln -sf "../input/"$i $i
		    fi
		done
	    else
		files=`( cd ../input ; ls -1 *.bin | grep -v CVS )`
		for i in $files ; do
		    if test ! -d "../input/"$i ; then
			ln -sf "../input/"$i $i
		    fi
		done
		files=`( cd ../input_ad ; ls -1 | grep -v CVS )`
		for i in $files ; do
		    if test ! -d "../input_ad/"$i ; then
			ln -sf "../input_ad/"$i $i
		    fi
		done
	    fi
	)
    fi
}

runmodel()
{
    # runmodel directory
    #
    #  runs "$COMMAND in "directory" 
    #  (where "$COMMAND" is relative to "directory")
    (
	cd $1
	printf 'runmodel ... ' 1>&2
	# make output.txt
	$COMMAND >> run.log 2>&1
	RETVAL=$?
	if test "x$RETVAL" = x0 ; then
	    echo successful 1>&2
	    if test "x$ADM" = x ; then
		cp output.txt $CDIR"/output.txt"
	    else
		cp output.txt_adm $CDIR"/output.txt_adm"
	    fi
	    return 0
	else
	    tail run.log
	    echo failed 1>&2
	    cp run.log $CDIR"/run.log"
	    return 1
	fi
    )
}

createcodelet()
{
    # create codelet for comparing model output

    echo -n "creating the comparison code...  "
    cat > tmp_cmpnum.c <<EOF
#include <stdio.h>
#include <math.h>
int main( int argc, char** argv )  {
  int linnum,best;
  double a,b,diff;
  best = -16;
  while( 1 )  {
    scanf("%d", &linnum);
    if (linnum == -1)  break;
    scanf("%lf", &a);  scanf("%lf", &b);
    diff = 0.5*(fabs(a)+fabs(b));
    if (diff > 1.e-12) {
      diff=fabs(a-b)/diff;
      if (diff > 0.0) {
        linnum = (int)log10(diff);
        best = (best > linnum) ? best : linnum;
      }
      else {
        if (best == -16 && diff != 0)  best = -22;
      }
    }
  }
  printf("%d\n", -best);
  return 0;
}
EOF
    cc -o tmp_cmpnum tmp_cmpnum.c -lm

    if [ -x ./tmp_cmpnum ]; then
	echo "OK"
	return 0
    else
	echo
	echo "ERROR: failed to compile comparison code" 
	exit 1
    fi
}

formatresults()
{
    # formatresults expt genmake depend make run results*

    nm=$1
    printf '%s %s %s %s' $2 $3 $4 $5
    shift; shift; shift; shift; shift;
    printf '%3s' $@
    
    if [ $1 = '--' ]; then
	printf ' N/O '
    else
	if [ $1 -gt 12 ]; then
	    printf ' pass'
	else
	    printf ' FAIL'
	fi
    fi
    printf '  %s' $nm
    printf '\n'
    
}

show_help()
{
    cat - << EOF
$0 [-help] [-quick] [-verbose] dir1 [dir2] [...]

 -help|-h      Show this help message
 -quiet     Reduce the amount of output
 -verbose   Produce copious amounts of output
 -debug     Produce even more output which will mean nothing to most
 -force     Do "make CLEAN" before compiling. This forces a complete rebuild.
 -clean     Do "make CLEAN" after compiling and testing.
 -cleanup   Aggresively removes all model output, executables and object files
            and then exits. Use with care.

Normal usage:
 $0 *       Configure, compile, run and analyze in all experiment directories
EOF
}

scandirs()
{
    if [ $# -eq 0 ]; then
	for arg in * ; do
	    test -d $arg/input && echo $arg
	done
    else
	echo $*
    fi
}


###############################################################################


#  Default properties
debug=0
verbose=1
clean=0
expts=''
# ieee=1

IEEE=
if test "x$MITGCM_IEEE" != x ; then
    IEEE=$MITGCM_IEEE
fi


CLEANUP=f
QUICK=f
NOGENMAKE=f
NOCLEAN=f
NODEPEND=f

BASH=
OPTFILE=NONE
ADDRESSES=
TESTDIRS=
MPACKDIR="../tools/mpack-1.6"
HAVE_MPACK=
MPACK="$MPACKDIR/mpack"
COMMAND=
MAKE=make
MPI=f

ADM=

echo -n "parsing options...  "

ac_prev=
for ac_option ; do

    # If the previous option needs an argument, assign it.
    if test -n "$ac_prev"; then
        eval "$ac_prev=\$ac_option"
        ac_prev=
        continue
    fi

    ac_optarg=`expr "x$ac_option" : 'x[^=]*=\(.*\)'`
    
    case $ac_option in
	
	-help | --help | -h | --h)
	    usage ;;
	
	-optfile | --optfile | -of | --of)
            ac_prev=OPTFILE ;;
        -optfile=* | --optfile=* | -of=* | --of=*)
            OPTFILE=$ac_optarg ;;
	
	-addr | --addr | -a | --a)
            ac_prev=ADDRESSES ;;
        -addr=* | --addr=*)
            ADDRESSES=$ac_optarg ;;

	-tdir | --tdir | -t | --t)
            ac_prev=TESTDIRS ;;
        -tdir=* | --tdir=*)
            TESTDIRS=$ac_optarg ;;

	-bash | --bash | -b | --b)
            ac_prev=BASH ;;
        -bash=* | --bash=*)
            BASH=$ac_optarg ;;

	-command | --command | -c | --c)
	    ac_prev=COMMAND ;;
	-command=* | --command=*)
	    COMMAND=$ac_optarg ;;

	-make | --make | -m | --m)
	    ac_prev=MAKE ;;
	-make=* | --make=*)
	    MAKE=$ac_optarg ;;

	-clean | --clean)
	    CLEANUP=t ;;

	-quick | --quick | -q | --q)
	    QUICK=t ;;
	-nogenmake | --nogenmake | -ng | --ng)
	    NOGENMAKE=t ;;
	-noclean | --noclean | -nc | --nc)
	    NOCLEAN=t ;;
	-nodepend | --nodepend | -nd | --nd)
	    NODEPEND=t ;;

	-mpi) MPI=t ;;

	-adm | -ad) ADM=t ;;

	-ieee) IEEE=true ;;
	-noieee) IEEE= ;;

	-verbose) verbose=2 ;;
	-debug) debug=1 ;;
	-quiet) verbose=0 ;;

        -*)
            echo "Error: unrecognized option: "$ac_option
            usage
            ;;
        
        *)
            echo "Error: unrecognized argument: "$ac_option
            usage
            ;;
        
     esac
     
done

if test "x$QUICK" = xt ; then
    NOGENMAKE=t
    NOCLEAN=t
    NODEPEND=t
fi

if test "x$TESTDIRS" = x ; then
    TESTDIRS=`scandirs`
fi

if test "x$OPTFILE" = xNONE -a "x$MITGCM_OF" != x ; then
    OPTFILE=$MITGCM_OF
fi

if test "x$ADM" = xt -a "x$COMMAND" = x ; then
    COMMAND="./mitgcmuv_ad > output.txt_adm 2>&1"
fi

if test "x$COMMAND" = x ; then
    COMMAND="make output.txt"
fi

echo "OK"

#  create the FORTRAN comparison code
createcodelet

#  build the mpack utility
build_mpack

#  Create a uniquely named directory to store results
MACH=`hostname`
UNAMEA=`uname -a`
DATE=`date +%Y%m%d`
BASE=$MACH"_"$DATE"_"
DNUM=0
DRESULTS="$BASE$DNUM"
while test -e $DRESULTS ; do
    DNUM=$(( $DNUM + 1 ))
    DRESULTS="$BASE$DNUM"
done
mkdir $DRESULTS
RETVAL=$?
if test "x$RETVAL" != x0 ; then
    echo "ERROR: Can't create results directory \"./$DRESULTS\""
    exit 1
fi
SUMMARY="$DRESULTS/summary.txt"
echo -n "Start time:  " >> $SUMMARY
start_date=`date`
echo $start_date > $SUMMARY

of_path=
if test "x$OPTFILE" != xNONE ; then
    if test -r $OPTFILE ; then
	# get the path
	path=${OPTFILE%/*}
	if test "x$path" = x ; then
	    of_path=`pwd`
	else
	    of_path=`( cd $path > /dev/null 2>&1 ; pwd )`
	fi
	file=${OPTFILE##*/}
	OPTFILE=$of_path/$file
	cp $OPTFILE $DRESULTS
	echo >> $SUMMARY
	echo "  OPTFILE=$OPTFILE" >> $SUMMARY
    else
	echo | tee $SUMMARY
	echo "ERROR: can't read OPTFILE=\"$OPTFILE\"" | tee $SUMMARY
	exit 1
    fi
else
    echo >> $SUMMARY
    echo "No \"OPTFILE\" was explicitly specified by testreport," >> $SUMMARY
    echo "   so the genmake default will be used." >> $SUMMARY
fi
echo
echo >> $SUMMARY
if test "x$ADM" = x ; then
    cat << EOF | tee -a $SUMMARY
                T           S           U           V
G D M    c        m  s        m  s        m  s        m  s
E p a R  g  m  m  e  .  m  m  e  .  m  m  e  .  m  m  e  .
N n k u  2  i  a  a  d  i  a  a  d  i  a  a  d  i  a  a  d
2 d e n  d  n  x  n  .  n  x  n  .  n  x  n  .  n  x  n  .

EOF
else
    echo "ADJOINT=true" >> $SUMMARY
    echo >> $SUMMARY
    cat << EOF | tee -a $SUMMARY
G D M    C  G
E p a R  o  r
N n k u  s  a
2 d e n  t  d

EOF
fi

#  ...and each test directory...
for dir in $TESTDIRS ; do
    
    #  Cleanup only!
    if test "x$CLEANUP" = xt ; then
	if test -r $dir/build/Makefile ; then
	    ( cd $dir/build ; make CLEAN )
	fi
	if test -r $dir/input/Makefile ; then
	    ( cd $dir/input ; make CLEAN )
	fi
	continue
    fi

    #  Verify that the testdir exists and contains previous 
    #  results in the correct location--or skip this directory!
    fout=
    if test "x$ADM" = x ; then
	fout=$dir"/results/output.txt"
    else
	fout=$dir"/results_ad/output.txt_adm"
    fi
    if test ! -r $fout ; then
	echo "can't read \"$fout\" -- skipping $dir"
	continue
    fi

    echo "-------------------------------------------------------------------------------"
    echo
    echo "Experiment:  $dir"
    echo
    unset genmake makedepend make run
    results='-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --'

    builddir="input"
    rundir="input"
    use_seperate_build=0
    if test -d $dir/build -a -r $dir/build ; then
	builddir="build"
	rundir="build"
	use_seperate_build=1
	linkdata $use_seperate_build $dir/$rundir
    fi
    
    if test "x$ADM" = x ; then
	CODE_DIR=$dir/code
    else
	CODE_DIR=$dir/code_ad
    fi
    BUILD_DIR=$dir/$builddir
    MPI_FILES="CPP_EEOPTIONS.h_mpi SIZE.h_mpi"
    NOMPI_FILES="CPP_EEOPTIONS.h_nompi SIZE.h_nompi"

    #  Is this an MPI run?
    if test "x$MPI" = xt ; then
	FILES=$MPI_FILES
	endings="_mpi"
    else
	FILES=$NOMPI_FILES
	endings="_nompi"
    fi
    
    #  Check to see that we have the files
    have_files=t
    for i in $FILES ; do
	if test ! -r $CODE_DIR/$i ; then
	    echo "Warning: can't read file $CODE_DIR/$i"
	    have_files=f
	fi
    done
    if test "x$have_files" != xt -a "x$MPI" = xt ; then
	echo "Skipping $dir due to lack of input files (see above warning)"
	continue
    fi
    
    #  If we have the $FILES and they differ, copy the $FILES to $BUILD_DIR
    if test "x$have_files" = xt ; then
	for i in $FILES ; do
	    sstr="s|$endings||"
	    name=`echo $i | sed -e $sstr `
	    cmp $CODE_DIR/$i $BUILD_DIR/$name > /dev/null 2>&1
	    RETVAL=$?
	    if test "x$RETVAL" != x0 ; then
		cp $CODE_DIR/$i $BUILD_DIR/$name
	    fi
	done
    fi
    
    #  Create an output dir for each OPTFILE/tdir combination
    rel_CDIR=$DRESULTS"/"$dir
    mkdir $rel_CDIR
    CDIR=`pwd`"/$rel_CDIR"
    
    if test "x$CLEANUP" = xt ; then
	makeclean $dir/$builddir
    else
	genmakemodel $dir/$builddir && genmake=Y \
	    && makeclean $dir/$builddir \
	    && makedependmodel $dir/$builddir && makedepend=Y \
	    && makemodel $dir/$builddir && make=Y \
	    && linkdata $use_seperate_build $dir/$rundir \
	    && runmodel $dir/$rundir && run=Y \
	    && results=`testoutput $dir $rundir`
    fi
    
    echo
    if test "x$ADM" = x ; then
	fres=`formatresults $dir ${genmake:-N} ${makedepend:-N} ${make:-N} ${run:-N} $results`
    else
	fres=`printf '%s %s %s %s' ${genmake:-N} ${makedepend:-N} ${make:-N} ${run:-N}`
	fres=$fres"$results   $dir"
    fi
    echo
    echo "$fres" >> $SUMMARY
    echo "fresults='$fres'" > $CDIR"/summary.txt"
    echo "MACH='$MACH'" >> $CDIR"/summary.txt"
    echo "UNAMEA='$UNAMEA'" >> $CDIR"/summary.txt"
    echo "DATE='$DATE'" >> $CDIR"/summary.txt"
    echo "tdir='$dir'" >> $CDIR"/summary.txt"
    
    echo "-------------------------------------------------------------------------------"
    
done

echo -n "Start time:  " >> $SUMMARY
echo $start_date >> $SUMMARY
echo -n "End time:    " >> $SUMMARY
date >> $SUMMARY

#  If addresses were supplied and mpack built successfully, then try
#  to send email using mpack.
if test "x$ADDRESSES" = xNONE -o "x$ADDRESSES" = x ; then
    echo "No results email was sent."
else
    if test "x$HAVE_MPACK" = xt ; then
	tar -cf $DRESULTS".tar" $DRESULTS > /dev/null 2>&1 \
	    && gzip $DRESULTS".tar" \
	    && $MPACK -s MITgcm-test -m 1500000 $DRESULTS".tar.gz" $ADDRESSES
	RETVAL=$?
	if test "x$RETVAL" != x0 ; then
	    echo
	    echo "Warning: The tar, gzip, & mpack step failed.  Please send email"
	    echo "  to <MITgcm-support@mitgcm.org> for help.  You may copy the "
	    echo "  summary of results from the directory \"$DRESULTS\"."
	    echo
	else
	    echo
	    echo "An email containing results was sent to the following addresses:"
	    echo "  \"$ADDRESSES\""
	    echo
	fi
	test -f $DRESULTS".tar"  &&  rm -f $DRESULTS".tar"
	test -f $DRESULTS".tar.gz"  &&  rm -f $DRESULTS".tar.gz"
    fi
fi

# rm -f tmp_cmpnum.f a.out
rm -f tmp_cmpnum.c tmp_cmpnum

if test "x$CLEANUP" != xt ; then
    cat $SUMMARY
    if test -e tr.out ; then
        mv tr.out tr.out.old
    fi
    cat $SUMMARY > tr.out
fi

