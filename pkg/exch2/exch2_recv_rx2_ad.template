C $Header: /home/jahn/src/cvs2git/MITgcm/20170915-2/gcmpack-all-patch/MITgcm/pkg/exch2/Attic/exch2_recv_rx2_ad.template,v 1.3 2008/08/01 00:45:16 jmc Exp $
C $Name:  $

#include "CPP_EEOPTIONS.h"
#include "W2_OPTIONS.h"

      SUBROUTINE EXCH2_RECV_RX2_AD(
     I       tIlo1, tIhi1, tIlo2, tIhi2, tiStride,
     I       tJlo1, tJhi1, tJlo2, tJhi2, tjStride,
     I       tKlo, tKhi, tkStride,
     I       thisTile, thisI, nN,
     I       e2Bufr1_RX, e2Bufr2_RX, e2BufrRecSize,
     I       mnb, nt,
     U       array1,
     I       i1Lo, i1Hi, j1Lo, j1Hi, k1Lo, k1Hi,
     U       array2,
     I       i2Lo, i2Hi, j2Lo, j2Hi, k2Lo, k2Hi,
     U       e2_msgHandle1,
     U       e2_msgHandle2,
     I       myTiles,
     I       commSetting,
     I       myThid )

      IMPLICIT NONE

#include "SIZE.h"
#include "EEPARAMS.h"
#include "EESUPPORT.h"
#include "W2_EXCH2_TOPOLOGY.h"

C     === Routine arguments ===
C     tIlo1,tIhi1,tIstride :: index range in I that will be filled in target "array1"
C     tIlo2,tIhi2,tIstride :: index range in I that will be filled in target "array2"
C     tJlo1,tJhi1,tJstride :: index range in J that will be filled in target "array1"
C     tJlo2,tJhi2,tJstride :: index range in J that will be filled in target "array2"
C     tKlo, tKhi, tKstride :: index range in K that will be filled in target arrays
C     thisTile             :: Rank of the receiveing tile
C     thisI                :: Index of the receiving tile within this process (used
C                          :: to select buffer slots that are allowed).
C     nN                   :: Neighbour entry that we are processing
C     e2Bufr1_RX           :: Data transport buffer array. This array is used in one of
C                          :: two ways. For PUT communication the entry in the buffer
C                          :: associated with the source for this receive (determined
C                          :: from the opposing_send index) is read. For MSG communication
C                          :: the entry in the buffer associated with this neighbor of this
C                          :: tile is used as a receive location for loading a linear
C                          :: stream of bytes.
C     e2BufrRecSize        :: Number of elements in each entry of e2Bufr1_RX
C     mnb                  :: Second dimension of e2Bufr1_RX
C     nt                   :: Third dimension of e2Bufr1_RX
C     array                :: Target array that this receive writes to.
C     i1Lo, i1Hi           :: I coordinate bounds of target array
C     j1Lo, j1Hi           :: J coordinate bounds of target array
C     k1Lo, k1Hi           :: K coordinate bounds of target array
C     e2_msgHandles        :: Synchronization and coordination data structure used to coordinate access
C                          :: to e2Bufr1_RX or to regulate message buffering. In PUT communication
C                          :: sender will increment handle entry once data is ready in buffer.
C                          :: Receiver will decrement handle once data is consumed from buffer. For
C                          :: MPI MSG communication MPI_Wait uses hanlde to check Isend has cleared.
C                          :: This is done in routine after receives.
C     myTiles              :: List of nt tiles that this process owns.
C     commSetting          :: Mode of communication used to exchnage with this neighbor
C     myThid               :: Thread number of this instance of EXCH2_RECV_RX2

      INTEGER tIlo1, tIhi1, tIlo2, tIhi2, tiStride
      INTEGER tJlo1, tJhi1, tJlo2, tJhi2, tjStride
      INTEGER tKlo, tKhi, tkStride
      INTEGER i1Lo, i1Hi, j1Lo, j1Hi, k1Lo, k1Hi
      INTEGER i2Lo, i2Hi, j2Lo, j2Hi, k2Lo, k2Hi
      INTEGER thisTile, nN, thisI
      INTEGER e2BufrRecSize
      INTEGER mnb, nt
      _RX     e2Bufr1_RX( e2BufrRecSize, mnb, nt, 2 )
      _RX     e2Bufr2_RX( e2BufrRecSize, mnb, nt, 2 )
      _RX     array1(i1Lo:i1Hi,j1Lo:j1Hi,k1Lo:k1Hi)
      _RX     array2(i2Lo:i2Hi,j2Lo:j2Hi,k2Lo:k2Hi)
      INTEGER e2_msgHandle1(1)
      INTEGER e2_msgHandle2(1)
      INTEGER myThid
      INTEGER myTiles(nt)
      CHARACTER commSetting

C     == Local variables ==
C     itl, jtl, ktl  :: Loop counters
C                    :: itl etc... target local
      INTEGER itl, jtl, ktl
C     tt         :: Target tile
C     iBufr1     :: Buffer counter
C     iBufr2     ::
      INTEGER tt
      INTEGER iBufr1, iBufr2
C     mb, nb :: Selects e2Bufr, msgHandle record to use
C     ir     ::
      INTEGER mb, nb, ir
C     oN     :: Opposing send record number
      INTEGER oN
C     Loop counters
      INTEGER I

C     MPI setup
#ifdef ALLOW_USE_MPI
      INTEGER theTag1, theTag2, theType
      INTEGER sProc, tProc, mpiRc
      INTEGER theHandle1, theHandle2
#ifdef W2_E2_DEBUG_ON
      CHARACTER*(MAX_LEN_MBUF) messageBuffer
#endif
#endif

      tt=exch2_neighbourId(nN, thisTile )
      oN=exch2_opposingSend(nN, thisTile )

C     Handle receive end data transport according to communication mechanism between
C     source and target tile
      IF     ( commSetting .EQ. 'P' ) THEN
C      1 Need to check and spin on data ready assertion for multithreaded mode, for now do nothing i.e.
C        assume only one thread per process.

C      2 Need to set e2Bufr to use put buffer from opposing send.
       oN = exch2_opposingSend(nN, thisTile )
       mb = oN
       ir = 1
       DO I=1,nt
        IF ( myTiles(I) .EQ. tt ) THEN
         nb = I
        ENDIF
       ENDDO
C      Get data from e2Bufr(1,mb,nb)
      ELSEIF ( commSetting .EQ. 'M' ) THEN
#ifdef ALLOW_USE_MPI
C      Setup MPI stuff here
       nb = thisI
       mb = nN
       ir = 2
#endif
      ELSE
       STOP 'EXCH2_RECV_RX2_AD:: commSetting VALUE IS INVALID'
      ENDIF

      iBufr1=0
      DO ktl=tKlo,tKhi,tkStride
       DO jtl=tJlo1, tJhi1, tjStride
        DO itl=tIlo1, tIhi1, tiStride
C        Read from e2Bufr1_RX(iBufr,mb,nb)
         iBufr1=iBufr1+1
         e2Bufr1_RX(iBufr1,mb,nb,ir) = array1(itl,jtl,ktl)
         array1(itl,jtl,ktl) = 0. _d 0
        ENDDO
       ENDDO
      ENDDO

      iBufr2=0
      DO ktl=tKlo,tKhi,tkStride
       DO jtl=tJlo2, tJhi2, tjStride
        DO itl=tIlo2, tIhi2, tiStride
C        Read from e2Bufr1_RX(iBufr,mb,nb)
         iBufr2=iBufr2+1
         e2Bufr2_RX(iBufr2,mb,nb,ir) = array2(itl,jtl,ktl)
         array2(itl,jtl,ktl) = 0. _d 0
        ENDDO
       ENDDO
      ENDDO

      IF     ( commSetting .EQ. 'P' ) THEN
      ELSEIF ( commSetting .EQ. 'M' ) THEN
#ifdef ALLOW_USE_MPI
C      Setup MPI stuff here
       nb = thisI
       mb = nN
       ir = 2
       theTag1 =  (tt-1)*MAX_NEIGHBOURS*2 + oN-1
     &         + 10000*(
     &            (thisTile-1)*MAX_NEIGHBOURS*2 + oN-1
     &           )
       theTag2 =  (tt-1)*MAX_NEIGHBOURS*2 + MAX_NEIGHBOURS + oN-1
     &         + 10000*(
     &            (thisTile-1)*MAX_NEIGHBOURS*2 + MAX_NEIGHBOURS + oN-1
     &           )
       tProc = exch2_tProc(thisTile)-1
       sProc = exch2_tProc(tt)-1
       theType = MPI_REAL8
       CALL MPI_Isend( e2Bufr1_RX(1,mb,nb,ir), iBufr1, theType, sProc,
     &               theTag1, MPI_COMM_MODEL, theHandle1, mpiRc )
       CALL MPI_Isend( e2Bufr2_RX(1,mb,nb,ir), iBufr2, theType, sProc,
     &               theTag2, MPI_COMM_MODEL, theHandle2, mpiRc )
       e2_msgHandle1(1) = theHandle1
       e2_msgHandle2(1) = theHandle2
#ifdef W2_E2_DEBUG_ON
       WRITE(messageBuffer,'(A,I4,A,I4,A)') ' RECV FROM TILE=', tt,
     I                                   ' (proc = ',sProc,')'
       CALL PRINT_MESSAGE(messageBuffer,
     I      standardMessageUnit,SQUEEZE_RIGHT,
     I      myThid)
       WRITE(messageBuffer,'(A,I4,A,I4,A)')
     I                             '      INTO TILE=', thisTile,
     I                             ' (proc = ',tProc,')'
       CALL PRINT_MESSAGE(messageBuffer,
     I      standardMessageUnit,SQUEEZE_RIGHT,
     I      myThid)
       WRITE(messageBuffer,'(A,I10)') '            TAG1=', theTag1
       CALL PRINT_MESSAGE(messageBuffer,
     I      standardMessageUnit,SQUEEZE_RIGHT,
     I      myThid)
       WRITE(messageBuffer,'(A,I4)') '            NEL1=', iBufr1
       CALL PRINT_MESSAGE(messageBuffer,
     I      standardMessageUnit,SQUEEZE_RIGHT,
     I      myThid)
       WRITE(messageBuffer,'(A,I10)') '            TAG2=', theTag2
       CALL PRINT_MESSAGE(messageBuffer,
     I      standardMessageUnit,SQUEEZE_RIGHT,
     I      myThid)
       WRITE(messageBuffer,'(A,I4)') '            NEL2=', iBufr2
       CALL PRINT_MESSAGE(messageBuffer,
     I      standardMessageUnit,SQUEEZE_RIGHT,
     I      myThid)
#endif /* W2_E2_DEBUG_ON */
C      Set mb to neighbour entry
C      Set nt to this tiles rank
       mb = nN
#endif
      ELSE
       STOP 'EXCH2_RECV_RX2_AD:: commSetting VALUE IS INVALID'
      ENDIF

      RETURN
      END

C---+----1----+----2----+----3----+----4----+----5----+----6----+----7-|--+----|

CEH3 ;;; Local Variables: ***
CEH3 ;;; mode:fortran ***
CEH3 ;;; End: ***
